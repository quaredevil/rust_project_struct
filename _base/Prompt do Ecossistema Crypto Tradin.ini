# 🚀 Prompt do Ecossistema Crypto Trading

## 📋 Visão Geral do Ecossistema

Você está trabalhando em um **ecossistema de microserviços para trading de criptomoedas** composto por 5 projetos independentes que se comunicam via **Apache Kafka**. O ecossistema é orientado a eventos, altamente desacoplado e projetado para escalabilidade e resiliência.

---

## 🏗️ Arquitetura do Ecossistema

```
┌─────────────────────────────────────────────────────────────────┐
│                        KAFKA CLUSTER                             │
│  Topics: trades, signals, notifications, webhooks, management    │
└─────────────────────────────────────────────────────────────────┘
                              ▲ │ ▼
        ┌─────────────────────┼─┼─┼─────────────────────┐
        │                     │ │ │                     │
        ▼                     ▼ │ ▼                     ▼
┌──────────────┐      ┌──────────────┐        ┌──────────────┐
│crypto-trader │      │crypto-signals│        │crypto-webhook│
│(Execução de  │◄────►│(Análise &    │───────►│(Integração   │
│ Ordens)      │      │ Estratégias) │        │ Externa)     │
└──────────────┘      └──────────────┘        └──────────────┘
        │                     │                        │
        └─────────┬───────────┴────────────────────────┘
                  ▼                           ▼
          ┌──────────────┐          ┌──────────────┐
          │crypto-notif. │          │crypto-mgmt   │
          │(Alertas &    │          │(Gestão &     │
          │ Comunicação) │          │ Config)      │
          └──────────────┘          └──────────────┘
```

---

## 🎯 Projetos e Suas Responsabilidades

### 1️⃣ **crypto-trader** (Executor de Ordens)
**Linguagem:** Python  
**Responsabilidade Principal:** Executar ordens de compra/venda em exchanges de criptomoedas

**O QUE FAZ:**
- ✅ Conecta-se a exchanges (Binance, Coinbase, etc.) via API
- ✅ Executa ordens de mercado, limit, stop-loss
- ✅ Publica eventos de trades realizados no Kafka
- ✅ Gerencia carteiras e saldos
- ✅ Implementa retry e circuit breaker para chamadas às exchanges

**O QUE NÃO FAZ:**
- ❌ NÃO analisa mercado ou gera sinais (responsabilidade do crypto-signals)
- ❌ NÃO envia notificações (responsabilidade do crypto-notifications)
- ❌ NÃO gerencia configurações globais (responsabilidade do crypto-management)
- ❌ NÃO integra com webhooks externos (responsabilidade do crypto-webhook)

**Consume:** `signals` (sinais de trading), `management.config` (configurações)  
**Produz:** `trades` (trades executados)

---

### 2️⃣ **crypto-signals** (Analisador e Gerador de Sinais)
**Linguagem:** Python  
**Responsabilidade Principal:** Analisar mercado e gerar sinais de trading

**O QUE FAZ:**
- ✅ Coleta dados de mercado (preços, volume, order book)
- ✅ Executa análise técnica (indicadores: RSI, MACD, Bollinger Bands)
- ✅ Implementa estratégias de trading (mean reversion, trend following)
- ✅ Gera sinais de BUY/SELL/HOLD
- ✅ Publica sinais no Kafka para consumo do crypto-trader
- ✅ Backtesting de estratégias

**O QUE NÃO FAZ:**
- ❌ NÃO executa ordens reais (responsabilidade do crypto-trader)
- ❌ NÃO envia alertas diretos aos usuários (responsabilidade do crypto-notifications)
- ❌ NÃO persiste configurações de usuários (responsabilidade do crypto-management)

**Consume:** `market.data` (dados de mercado), `management.strategy` (configs de estratégias)  
**Produz:** `signals` (sinais de trading)

---

### 3️⃣ **crypto-notifications** (Central de Notificações)
**Linguagem:** Python  
**Responsabilidade Principal:** Enviar notificações multi-canal aos usuários

**O QUE FAZ:**
- ✅ Consome eventos de todos os projetos do ecossistema
- ✅ Envia notificações via Email, SMS, Telegram, Discord, Slack
- ✅ Formata mensagens específicas para cada canal
- ✅ Gerencia templates de mensagens
- ✅ Controla frequência e throttling de notificações
- ✅ Rastreia status de entrega

**O QUE NÃO FAZ:**
- ❌ NÃO decide quando notificar (consome eventos já publicados)
- ❌ NÃO executa lógica de negócio (apenas notifica)
- ❌ NÃO armazena preferências de usuários permanentemente (busca do crypto-management)

**Consume:** `trades`, `signals`, `webhooks.events`, `management.alerts`  
**Produz:** `notifications.sent`, `notifications.failed`

---

### 4️⃣ **crypto-webhook** (Integração com Sistemas Externos)
**Linguagem:** Node.js  
**Responsabilidade Principal:** Receber e processar webhooks de sistemas externos

**O QUE FAZ:**
- ✅ Expõe endpoints HTTP para receber webhooks
- ✅ Valida assinaturas e autenticação de webhooks
- ✅ Normaliza payloads de diferentes fontes (TradingView, Exchanges, APIs)
- ✅ Publica eventos normalizados no Kafka
- ✅ Gerencia rate limiting e segurança

**O QUE NÃO FAZ:**
- ❌ NÃO executa ordens (apenas publica eventos)
- ❌ NÃO analisa dados (apenas normaliza e encaminha)
- ❌ NÃO envia notificações (apenas recebe e publica)

**Consume:** Nenhum (é ponto de entrada HTTP)  
**Produz:** `webhooks.events`, `external.signals`

---

### 5️⃣ **crypto-management** (Gestão e Configuração)
**Linguagem:** Python  
**Responsabilidade Principal:** Gerenciar usuários, configurações e monitoramento

**O QUE FAZ:**
- ✅ CRUD de usuários e suas preferências
- ✅ Gerenciamento de API Keys de exchanges
- ✅ Configuração de estratégias de trading
- ✅ Dashboard de monitoramento e métricas
- ✅ Auditoria e logs centralizados
- ✅ Health checks de todos os serviços
- ✅ Publica configurações via Kafka para outros serviços

**O QUE NÃO FAZ:**
- ❌ NÃO executa trades (responsabilidade do crypto-trader)
- ❌ NÃO gera sinais (responsabilidade do crypto-signals)
- ❌ NÃO envia notificações diretamente (publica eventos para crypto-notifications)

**Consume:** `trades`, `signals`, `notifications.*` (para métricas)  
**Produz:** `management.config`, `management.strategy`, `management.alerts`

---

## 🔒 Fronteiras e Princípios Arquiteturais

### **Princípio da Responsabilidade Única**
Cada projeto tem UMA responsabilidade clara e bem definida. Não há sobreposição.

### **Comunicação Assíncrona**
- Todos os projetos se comunicam APENAS via Kafka
- Nenhuma chamada HTTP direta entre microserviços (exceto crypto-webhook que recebe HTTP externo)
- Padrão Publish/Subscribe para desacoplamento máximo

### **Independência de Deploy**
- Cada projeto pode ser deployado, escalado e versionado independentemente
- Mudanças em um projeto NÃO devem quebrar outros

### **Eventos como Contrato**
- Schemas de eventos Kafka são o contrato entre serviços
- Versionamento de schemas usando Schema Registry (Avro/JSON Schema)

---

## 📊 Tópicos Kafka do Ecossistema

| Tópico | Produtor | Consumidores | Payload |
|--------|----------|--------------|---------|
| `signals` | crypto-signals | crypto-trader | Sinais de BUY/SELL |
| `trades` | crypto-trader | crypto-notifications, crypto-management | Trades executados |
| `webhooks.events` | crypto-webhook | crypto-signals, crypto-notifications | Eventos externos |
| `notifications.sent` | crypto-notifications | crypto-management | Notificações enviadas |
| `management.config` | crypto-management | crypto-trader, crypto-signals | Configurações |
| `management.strategy` | crypto-management | crypto-signals | Estratégias de trading |

---

## 🛠️ Stack Tecnológica

**Backend:**
- Python: crypto-trader, crypto-signals, crypto-notifications, crypto-management
- Node.js: crypto-webhook

**Mensageria:**
- Apache Kafka + Zookeeper
- Schema Registry (Confluent)

**Banco de Dados:**
- PostgreSQL (crypto-management - dados transacionais)
- MongoDB (crypto-signals - dados de mercado time-series)
- Redis (cache compartilhado)

**Infraestrutura:**
- Docker + Docker Compose
- Kubernetes (produção)
- Prometheus + Grafana (monitoramento)

---

## 🔄 Fluxo de Exemplo (Trade Completo)

1. **TradingView** → envia webhook → **crypto-webhook**
2. **crypto-webhook** → publica `webhooks.events` → **Kafka**
3. **crypto-signals** → consome evento → analisa → publica `signals` → **Kafka**
4. **crypto-trader** → consome sinal → executa ordem na Binance → publica `trades` → **Kafka**
5. **crypto-notifications** → consome trade → envia Telegram + Email ao usuário
6. **crypto-management** → consome trade → atualiza dashboard de métricas

---

## ⚠️ Pontos de Atenção

### **Idempotência**
Todos os consumers devem ser idempotentes (processar mesma mensagem 2x não gera efeito colateral)

### **Dead Letter Queues**
Mensagens com falha vão para tópicos `.dlq` para análise posterior

### **Circuit Breaker**
Implementado em chamadas a APIs externas (exchanges, provedores de notificação)

### **Rate Limiting**
- Respeito aos limites de API das exchanges
- Controle de frequência de notificações

### **Segurança**
- API Keys encriptadas no crypto-management
- Validação de assinaturas em webhooks
- Autenticação JWT entre serviços quando necessário



# ============================================================================
# ECOSSISTEMA CRYPTO TRADING - DOCUMENTAÇÃO DE INTEGRAÇÃO
# ============================================================================
# Última atualização: 17/10/2025
# Descrição: Documentação centralizada de todos os serviços do ecossistema
# ============================================================================

# ============================================================================
# SERVIÇO: CRYPTO-NOTIFICATIONS
# ============================================================================
# Repositório: crypto-notifications
# Linguagem: Rust
# Tipo: Kafka Consumer Worker (Event-Driven)
# Versão: 1.0.0
# Descrição: Serviço de processamento e entrega de notificações multi-canal
#            com throttling, retry automático e formatação inteligente
# ============================================================================

[crypto-notifications]
name = "Crypto Notifications Service"
version = "1.0.0"
language = "Rust"
framework = "Tokio (async runtime)"
architecture = "Event-Driven, Domain-Driven Design (DDD)"
type = "Kafka Consumer Worker"

# ----------------------------------------------------------------------------
# KAFKA TOPICS - CONSUMER
# ----------------------------------------------------------------------------
[crypto-notifications.kafka.consumer]
# Tópico de entrada para receber requisições de notificação de outros serviços
topic = "crypto_notification"
group_id = "crypto-notifications-group"
auto_offset_reset = "earliest"
schema_registry = "http://localhost:8081"
schema = "com.crypto.notifications.NotificationMessage"
description = "Consome mensagens de notificação de todos os serviços do ecossistema"

# Estrutura da mensagem (Avro Schema):
# - channel: TELEGRAM | DISCORD | EMAIL | WEBHOOK | ALL
# - priority: LOW | NORMAL | HIGH | CRITICAL
# - category: ORDER | POSITION | SIGNAL | ALERT | REPORT | SYSTEM
# - title: string (max 200 chars)
# - message: string (max 4000 chars)
# - data: map<string, string> (opcional, key-value pairs)
# - timestamp: long (epoch millis)

# ----------------------------------------------------------------------------
# KAFKA TOPICS - PRODUCERS
# ----------------------------------------------------------------------------
[crypto-notifications.kafka.producers]
# Tópicos de saída para eventos de status das notificações

[[crypto-notifications.kafka.producers.topics]]
name = "crypto_notification_delivered"
schema = "com.crypto.notifications.NotificationDelivered"
description = "Notificações entregues com sucesso"
# Campos: notification_id, channel, timestamp, delivery_time_ms, attempts

[[crypto-notifications.kafka.producers.topics]]
name = "crypto_notification_failed"
schema = "com.crypto.notifications.NotificationFailed"
description = "Notificações que falharam após todas as tentativas de retry"
# Campos: notification_id, channel, error, timestamp, attempts, last_error_message

[[crypto-notifications.kafka.producers.topics]]
name = "crypto_notification_throttled"
schema = "com.crypto.notifications.NotificationThrottled"
description = "Notificações rejeitadas por throttling/rate limiting"
# Campos: notification_id, channel, timestamp, retry_after_seconds, current_rate

# ----------------------------------------------------------------------------
# ENDPOINTS REST API
# ----------------------------------------------------------------------------
[crypto-notifications.endpoints]
# ⚠️ IMPORTANTE: Este serviço NÃO expõe endpoints HTTP REST
# É um worker Kafka puro, sem interface HTTP
# Comunicação apenas via Kafka topics
type = "none"
description = "Serviço worker sem API REST - comunicação 100% via Kafka"

# ----------------------------------------------------------------------------
# DEPENDÊNCIAS EXTERNAS
# ----------------------------------------------------------------------------
[crypto-notifications.dependencies]

[crypto-notifications.dependencies.kafka]
service = "Apache Kafka"
brokers = "localhost:9092"
required = true
description = "Message broker para consumo e produção de eventos"

[crypto-notifications.dependencies.schema-registry]
service = "Confluent Schema Registry"
url = "http://localhost:8081"
required = true
description = "Registro de schemas Avro para serialização/deserialização"

[crypto-notifications.dependencies.redis]
service = "Redis"
url = "redis://localhost:6379"
required = true
description = "Cache para throttling/rate limiting e deduplicação"

[crypto-notifications.dependencies.telegram]
service = "Telegram Bot API"
url = "https://api.telegram.org"
required = false
description = "API para envio de notificações via Telegram"
config = "Requer BOT_TOKEN e CHAT_ID"

[crypto-notifications.dependencies.postgres]
service = "PostgreSQL"
required = false
description = "Persistência opcional para event store (futuro)"

# ----------------------------------------------------------------------------
# CARACTERÍSTICAS PRINCIPAIS
# ----------------------------------------------------------------------------
[crypto-notifications.features]
channels = ["Telegram", "Discord (futuro)", "Email (futuro)", "Webhook (futuro)"]
throttling = "Rate limiting por canal com Redis"
retry = "Exponential backoff automático (3 tentativas padrão)"
formatting = "Formatação inteligente com emojis por categoria"
priorities = ["LOW", "NORMAL", "HIGH", "CRITICAL"]
categories = ["ORDER", "POSITION", "SIGNAL", "ALERT", "REPORT", "SYSTEM"]
architecture_pattern = "Domain-Driven Design (DDD) com Event Sourcing"

# ----------------------------------------------------------------------------
# CONFIGURAÇÃO DO RETRY
# ----------------------------------------------------------------------------
[crypto-notifications.retry]
max_attempts = 3
base_delay_seconds = 2
max_delay_seconds = 60
strategy = "Exponential Backoff"

# ----------------------------------------------------------------------------
# THROTTLING / RATE LIMITING
# ----------------------------------------------------------------------------
[crypto-notifications.throttling]
backend = "Redis"
per_channel = true
description = "Rate limiting configurável por canal de notificação"

# ----------------------------------------------------------------------------
# VARIÁVEIS DE AMBIENTE PRINCIPAIS
# ----------------------------------------------------------------------------
[crypto-notifications.environment]
APP__NAME = "crypto-notifications"
APP__LOG_LEVEL = "info"
KAFKA__BROKERS = "localhost:9092"
KAFKA__CONSUMER_GROUP = "crypto-notifications-group"
KAFKA__TOPIC_NOTIFICATION = "crypto_notification"
KAFKA__TOPIC_DELIVERED = "crypto_notification_delivered"
KAFKA__TOPIC_FAILED = "crypto_notification_failed"
KAFKA__TOPIC_THROTTLED = "crypto_notification_throttled"
KAFKA__SCHEMA_REGISTRY_URL = "http://localhost:8081"
REDIS__URL = "redis://localhost:6379"
TELEGRAM__BOT_TOKEN = "<required>"
TELEGRAM__CHAT_ID = "<required>"
TELEGRAM__ENABLED = "true"

# ----------------------------------------------------------------------------
# COMO OUTROS SERVIÇOS DEVEM INTEGRAR
# ----------------------------------------------------------------------------
[crypto-notifications.integration]
description = """
Para enviar notificações ao ecossistema, publique mensagens no tópico
'crypto_notification' seguindo o schema Avro especificado.

Exemplo de uso:
1. Produzir mensagem no topic 'crypto_notification'
2. Aguardar eventos nos topics de resposta (delivered/failed/throttled)
3. Monitorar logs para troubleshooting

Categorias recomendadas por tipo de evento:
- ORDER: Execução de ordens, fills, cancelamentos
- POSITION: Abertura/fechamento de posições, stop loss, take profit
- SIGNAL: Sinais de trading, indicadores técnicos
- ALERT: Alertas de preço, volume, volatilidade
- REPORT: Relatórios periódicos, balanços, performance
- SYSTEM: Status do sistema, health checks, erros críticos

Prioridades recomendadas:
- CRITICAL: Erros graves, liquidações, margin calls
- HIGH: Execuções de ordem importantes, sinais urgentes
- NORMAL: Notificações padrão do dia a dia
- LOW: Relatórios não urgentes, informativos
"""

# ============================================================================
# OBSERVAÇÕES GERAIS DO ECOSSISTEMA
# ============================================================================
[ecosystem.notes]
description = """
O serviço crypto-notifications atua como hub central de notificações para
todos os serviços do ecossistema crypto trading. Qualquer serviço pode enviar
notificações através do Kafka topic 'crypto_notification' e receber confirmação
através dos topics de eventos (delivered/failed/throttled).

O serviço garante:
- Entrega confiável com retry automático
- Rate limiting para evitar spam
- Formatação consistente com contexto semântico
- Suporte multi-canal (Telegram inicialmente, outros no futuro)
- Rastreabilidade completa via event sourcing
"""

# ============================================================================
# FIM DA DOCUMENTAÇÃO
# ============================================================================



---

**Este é o contexto completo do ecossistema. Use-o como referência para entender onde cada funcionalidade deve ser implementada e como os projetos interagem.**