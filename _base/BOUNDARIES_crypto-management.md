# üö® FRONTEIRAS ESTRITAS - CRYPTO-MANAGEMENT

## ‚ö†Ô∏è Este projeto √â:
- ‚úÖ O **C√âREBRO** do sistema (orquestrador central)
- ‚úÖ Um **GERENCIADOR** de posi√ß√µes globais
- ‚úÖ Um **CONTROLADOR** de estrat√©gias e modos
- ‚úÖ Um **APLICADOR** de risk management central
- ‚úÖ Um **DETECTOR** de trades manuais (auto-discovery)

## ‚ùå Este projeto N√ÉO √â:

### 1. N√ÉO √© um Executor de Ordens
```yaml
‚ùå PROIBIDO:
  - Executar ordens diretamente na exchange
  - Conectar com Binance API para criar/cancelar ordens
  - Gerenciar stops de ordens espec√≠ficas
  - Monitorar execu√ß√£o de ordens individuais
  
‚úÖ SOLU√á√ÉO:
  - Publique comandos em Kafka
  - crypto-trader consome e executa
  - Voc√™ COORDENA, n√£o EXECUTA
```

### 2. N√ÉO √© um Gerador de Sinais
```yaml
‚ùå PROIBIDO:
  - Calcular indicadores t√©cnicos
  - Analisar mercado
  - Gerar sinais de BUY/SELL
  - Implementar estrat√©gias de trading
  
‚úÖ SOLU√á√ÉO:
  - crypto-signals gera sinais
  - Voc√™ CONTROLA estrat√©gias (enable/disable)
  - Mas N√ÉO implementa as estrat√©gias
```

### 3. N√ÉO √© um Sistema de Notifica√ß√µes
```yaml
‚ùå PROIBIDO:
  - Enviar mensagens para Telegram/Discord/Email
  - Formatar mensagens para usu√°rios
  - Implementar clients de notifica√ß√£o
  - Gerenciar templates de mensagens
  
‚úÖ SOLU√á√ÉO:
  - Publique eventos no Kafka
  - crypto-notifications consome e notifica
  - Inclua todos os dados necess√°rios no evento
```

### 4. N√ÉO √© um Receptor de Webhooks
```yaml
‚ùå PROIBIDO:
  - Expor endpoints HTTP para receber webhooks
  - Validar assinaturas de webhooks externos
  - Normalizar payloads do TradingView
  
‚úÖ SOLU√á√ÉO:
  - crypto-webhook recebe webhooks
  - Voc√™ pode expor API REST de CONTROLE (n√£o webhooks)
  - APIs: GET status, POST config, etc.
```

### 5. N√ÉO Gerencia Stops de Ordens Espec√≠ficas
```yaml
‚ùå PROIBIDO:
  - Monitorar stop loss de cada ordem
  - Disparar trailing stops
  - Ajustar stops dinamicamente por ordem
  
‚úÖ SOLU√á√ÉO:
  - crypto-trader gerencia stops de ordens
  - Voc√™ gerencia posi√ß√µes (agregado de ordens)
  - Monitora RESULTADO, n√£o execu√ß√£o
```

---

## üìã Checklist Antes de Implementar

Pergunte-se:

### ‚ùì Estou executando ordens diretamente?
- Se SIM ‚Üí **PARE!** Isso √© crypto-trader
- **OK:** Publicar comando para crypto-trader executar

### ‚ùì Estou calculando indicadores ou gerando sinais?
- Se SIM ‚Üí **PARE!** Isso √© crypto-signals
- **OK:** Enable/disable estrat√©gias, n√£o implement√°-las

### ‚ùì Estou enviando notifica√ß√µes diretas?
- Se SIM ‚Üí **PARE!** Isso √© crypto-notifications
- **Solu√ß√£o:** Publique evento com dados completos

### ‚ùì Estou recebendo webhooks externos?
- Se SIM ‚Üí **PARE!** Isso √© crypto-webhook
- **OK:** Expor API REST de controle/consulta

### ‚ùì Estou gerenciando stop loss de ordem individual?
- Se SIM ‚Üí **PARE!** Isso √© crypto-trader
- **OK:** Gerenciar posi√ß√£o (agregado de m√∫ltiplas ordens)

---

## ‚úÖ O QUE VOC√ä PODE/DEVE FAZER

### 1. Gerenciar Posi√ß√µes Globais
```rust
// ‚úÖ CORRETO
async fn track_position(order_filled: OrderFilledEvent) {
    let position = positions_store.get_or_create(&order_filled.symbol).await;
    
    match order_filled.side {
        Buy => position.add_entry(order_filled),
        Sell => position.add_exit(order_filled),
    }
    
    // Calcular P&L
    let pnl = calculate_pnl(&position);
    
    // Atualizar estado
    positions_store.update(position).await;
    
    // Publicar evento
    kafka.send("management.positions.updated", PositionUpdatedEvent {
        position_id: position.id,
        unrealized_pnl: pnl,
        // ...
    }).await;
}
```

### 2. Auto-Discovery de Trades Manuais
```rust
// ‚úÖ CORRETO
async fn detect_manual_trade(user_data: UserDataStreamEvent) {
    // Trade n√£o veio do crypto-trader
    if !known_orders.contains(&user_data.order_id) {
        // Nova posi√ß√£o detectada
        let position = create_position_from_manual_trade(user_data);
        
        // Publicar evento
        kafka.send("management.positions.opened", PositionOpenedEvent {
            position_id: position.id,
            source: "manual",
            // ...
        }).await;
        
        // Solicitar subscri√ß√£o de pre√ßos
        kafka.send("crypto-listener.subscribe", SubscribeEvent {
            symbol: position.symbol,
        }).await;
    }
}
```

### 3. Calcular P&L de Portfolio
```rust
// ‚úÖ CORRETO
async fn calculate_portfolio_pnl() -> PortfolioPnL {
    let open_positions = positions_store.get_open().await;
    let closed_positions = positions_store.get_closed_today().await;
    
    let unrealized_pnl = open_positions
        .iter()
        .map(|p| p.unrealized_pnl)
        .sum();
    
    let realized_pnl = closed_positions
        .iter()
        .map(|p| p.realized_pnl)
        .sum();
    
    PortfolioPnL {
        unrealized: unrealized_pnl,
        realized: realized_pnl,
        total: unrealized_pnl + realized_pnl,
    }
}
```

### 4. Aplicar Risk Management Central
```rust
// ‚úÖ CORRETO
async fn validate_risk(signal: SignalEvent) -> Result<(), RiskViolation> {
    let portfolio = get_portfolio_state().await;
    let risk_limits = load_risk_limits().await;
    
    // Validar exposi√ß√£o
    let new_exposure = portfolio.exposure + signal.quantity * signal.price;
    if new_exposure > risk_limits.max_total_exposure {
        return Err(RiskViolation::ExposureExceeded);
    }
    
    // Validar drawdown
    if portfolio.drawdown > risk_limits.max_drawdown {
        return Err(RiskViolation::DrawdownExceeded);
    }
    
    Ok(())
}

// ‚ùå ERRADO - Executar ordem ap√≥s validar
async fn validate_and_execute(signal: Signal) {
    validate_risk(&signal).await?;
    // ‚ùå N√ÉO FA√áA ISSO!
    exchange_client.create_order(signal).await; // ERRADO!
    
    // ‚úÖ CORRETO: Publicar aprova√ß√£o
    kafka.send("signals.approved", signal).await;
}
```

### 5. Controlar Estrat√©gias
```rust
// ‚úÖ CORRETO
async fn enable_strategy(strategy: String, symbols: Vec<String>) {
    // Atualizar estado local
    strategy_store.enable(&strategy, &symbols).await;
    
    // Publicar comando
    kafka.send("management.control.strategy", StrategyControlEvent {
        action: "ENABLE",
        strategy,
        symbols,
    }).await;
}

// ‚ùå ERRADO - Implementar a estrat√©gia
async fn execute_rsi_strategy() {
    // N√ÉO FA√áA ISSO!
    let rsi = calculate_rsi(&prices); // Isso √© crypto-signals
    if rsi < 30 {
        // ...
    }
}
```

### 6. Controlar Modo de Opera√ß√£o
```rust
// ‚úÖ CORRETO
async fn change_mode(mode: OperationMode) {
    // Atualizar estado
    system_state.set_mode(mode).await;
    
    // Publicar comando
    kafka.send("management.control.mode", ModeControlEvent {
        mode,
        timestamp: Utc::now(),
    }).await;
}
```

### 7. Coordenar Subscri√ß√µes de Assets
```rust
// ‚úÖ CORRETO
async fn subscribe_to_asset(symbol: String, reason: String) {
    kafka.send("crypto-listener.subscribe", SubscribeEvent {
        symbol,
        source: reason,
        priority: "high",
    }).await;
}

async fn unsubscribe_from_asset(symbol: String) {
    // Verificar se ainda h√° posi√ß√µes abertas
    if !has_open_positions(&symbol).await {
        kafka.send("crypto-listener.unsubscribe", UnsubscribeEvent {
            symbol,
            reason: "position_closed",
        }).await;
    }
}
```

---

## üîó Comunica√ß√£o com Outros Projetos

### CONSOME (via Kafka):
- ‚úÖ `orders.events` (de crypto-trader)
- ‚úÖ `signals.buy` (de crypto-signals, crypto-webhook)
- ‚úÖ `signals.sell` (de crypto-signals, crypto-webhook)
- ‚úÖ `crypto-listener.prices` (para P&L n√£o realizado)

### PRODUZ (via Kafka):
- ‚úÖ `management.positions.opened` (para crypto-notifications)
- ‚úÖ `management.positions.closed` (para crypto-notifications)
- ‚úÖ `management.positions.updated` (para crypto-notifications)
- ‚úÖ `management.control.strategy` (para crypto-signals, crypto-trader)
- ‚úÖ `management.control.risk` (para crypto-trader)
- ‚úÖ `management.control.mode` (para crypto-trader)
- ‚úÖ `crypto-listener.subscribe` (para crypto-listener)
- ‚úÖ `crypto-listener.unsubscribe` (para crypto-listener)

### PROIBIDO:
- ‚ùå Chamar Exchange API diretamente para executar ordens
- ‚ùå Implementar an√°lise t√©cnica
- ‚ùå Enviar notifica√ß√µes diretas (Telegram/Discord)

---

## üéØ Mantra do crypto-management

```
EU ORQUESTRO E COORDENO.
EU GERENCIO POSI√á√ïES, N√ÉO ORDENS (crypto-trader gerencia ordens).
EU CONTROLO ESTRAT√âGIAS, N√ÉO AS IMPLEMENTO (crypto-signals implementa).
EU PUBLICO COMANDOS, N√ÉO EXECUTO DIRETAMENTE.
EU SOU O C√âREBRO, N√ÉO OS BRA√áOS.
```

---

## üí° Padr√£o de Implementa√ß√£o Correto

### Fluxo de Orquestra√ß√£o:
```rust
// Exemplo: Coordenar abertura de posi√ß√£o
async fn orchestrate_position_opening(order_filled: OrderFilledEvent) {
    // 1. Criar/atualizar posi√ß√£o
    let position = create_or_update_position(order_filled).await;
    
    // 2. Publicar evento de posi√ß√£o
    kafka.send("management.positions.opened", PositionOpenedEvent {
        position_id: position.id,
        symbol: position.symbol.clone(),
        // ...
    }).await;
    
    // 3. Solicitar subscri√ß√£o de pre√ßos
    kafka.send("crypto-listener.subscribe", SubscribeEvent {
        symbol: position.symbol,
        source: "position_opened",
    }).await;
    
    // ‚úÖ PARE AQUI! Voc√™ coordenou, n√£o executou.
    // crypto-notifications envia alertas
    // crypto-listener come√ßa a enviar pre√ßos
    // crypto-trader monitora stops (se houver)
}

// Exemplo: Coordenar fechamento de posi√ß√£o
async fn orchestrate_position_closing(order_filled: OrderFilledEvent) {
    // 1. Atualizar posi√ß√£o
    let position = close_position(order_filled).await;
    
    // 2. Calcular P&L
    let pnl = calculate_pnl(&position);
    
    // 3. Publicar evento de fechamento
    kafka.send("management.positions.closed", PositionClosedEvent {
        position_id: position.id,
        pnl: pnl.total,
        pnl_percent: pnl.percent,
        // ...
    }).await;
    
    // 4. Cancelar subscri√ß√£o (se n√£o houver outras posi√ß√µes)
    if !has_other_positions(&position.symbol).await {
        kafka.send("crypto-listener.unsubscribe", UnsubscribeEvent {
            symbol: position.symbol,
        }).await;
    }
}
```

---

## ‚ö†Ô∏è Armadilhas Comuns

### ‚ùå ERRADO: "Executar Diretamente"
```rust
// N√ÉO FA√áA ISSO!
async fn close_position_directly(position_id: Uuid) {
    let position = get_position(position_id).await;
    
    // ‚ùå Executando ordem diretamente
    exchange_client.create_order(Order {
        symbol: position.symbol,
        side: Sell,
        quantity: position.quantity,
    }).await;
    
    // ERRADO! Publique comando para crypto-trader
}
```

### ‚ùå ERRADO: "Implementar Estrat√©gia"
```rust
// N√ÉO FA√áA ISSO!
async fn check_if_should_close_position(position: &Position) {
    // ‚ùå Analisando mercado
    let current_price = get_price(&position.symbol).await;
    let rsi = calculate_rsi(&prices); // ERRADO!
    
    if rsi > 70 {
        // ‚ùå Gerando sinal
        close_position(position).await;
    }
    
    // Isso √© trabalho do crypto-signals!
}
```

### ‚úÖ CORRETO: "Coordenar via Eventos"
```rust
async fn handle_risk_violation(portfolio: &Portfolio) {
    // ‚úÖ Publicar comando de parada emergencial
    kafka.send("management.control.risk", RiskControlEvent {
        action: "HALT_TRADING",
        reason: "Max drawdown exceeded",
    }).await;
    
    // ‚úÖ Publicar alerta
    kafka.send("management.alerts", AlertEvent {
        severity: "critical",
        message: "Trading halted due to risk violation",
    }).await;
    
    // Outros servi√ßos reagem aos comandos
}
```

---

## üéì Seu Papel como Orquestrador

Voc√™ √© o maestro, n√£o o m√∫sico:
- ‚úÖ Voc√™ COORDENA quem faz o que
- ‚úÖ Voc√™ MANT√âM o estado global
- ‚úÖ Voc√™ APLICA regras globais (risco, limites)
- ‚úÖ Voc√™ DETECTA anomalias (trades manuais)
- ‚ùå Voc√™ N√ÉO executa as a√ß√µes diretamente

**Se voc√™ est√° chamando Exchange API ou implementando estrat√©gias, PARE!**

